# 词法分析实验报告

<center><div style='height:2mm;'></div><div style="font-size:14pt;">池纪君 2019213688 2019211301班</div></center>
<center><span style="font-size:9pt;line-height:9mm">北京邮电大学 计算机学院</span>
</center>

# 实验题目

## 实验内容

​		语法分析程序的设计与实现

## 实验要求

### 设计要求

​		编写语法分析程序，实现对算术表达式的语法分析。要求所分析算术表达式由如下文法产生。
$$
E\rightarrow E+T\space|\space E-T\space |\space T\\
T\rightarrow T*F\space|\space T/F\space |\space F\\
F\rightarrow (E)\space|\space num
$$

### 输出要求

​		在对输入的算术表达式进行分析过程中，依次出所采用产生。

### 实现方法要求

1. 编写递归调用程序实现自顶向下的分析。 
2. 编写 LL(1) 语法分析程序。 
3. 编写语法分析程序实现自底向上的分析。
4. 4：利用 YACC 自动生成语法分析程序，调用LEX自动生成的词法分析程序。



# 程序设计说明

## 实验环境

​		本实验在Windows WSL2上进行开发，其中C语言环境为 gcc (Ubuntu 9.3.0-17ubuntu1~20.04) 9.3.0 和 cmake version 3.16.3。

## 文法的存储和相关算法的设计与实现

### 文法类的设计

![grammardrawio](词法分析实验报告.assets/grammardrawio.png)



### 消除左递归

1. 问题：消除左递归的目的是为了防止在递归下降分析和LL分析的过程中产生无穷递归的死循环问题。

2. 算法：对文法$G=\left(\mathbf{V}_{\mathrm{T}}, \mathbf{V}_{\mathrm{N}}, \mathbf{S}, \varphi\right)$，可以用如下算法消除左递归：![image-20211120165946072](词法分析实验报告.assets/image-20211120165946072-16373987874054.png)



### 提取左公因子

1. 问题：提取左部公因子的目的是为了使得LL(1)的每个非终结符（包括新产生的非终结符）的所有候选式首部符号两两不相交。		

2. 算法：

   * 如有产生式 $\mathrm{A} \rightarrow \alpha \beta_{1} \mid \alpha \beta_{2}$ 提取左公因子 $\alpha$, 则原产生式变为：$\begin{aligned}
     &\mathbf{A} \rightarrow \alpha \mathbf{A}^{\prime} \\
     &\mathbf{A}^{\prime} \rightarrow \beta_{1} \mid \beta_{2}
     \end{aligned}$

   * 若有产生式 $\mathrm{A} \rightarrow \alpha \beta_{1}\left|\alpha \beta_{2}\right| \ldots\left|\alpha \beta_{\mathrm{n}}\right| \gamma$ 可用如下的产生式代替：$\begin{aligned}
     &\mathbf{A} \rightarrow \alpha \mathbf{A}^{\prime} \mid \gamma \\
     &\mathbf{A}^{\prime} \rightarrow \beta_{1}\left|\beta_{2}\right| \ldots \mid \beta_{\mathrm{n}}
     \end{aligned}$

### 计算 $\operatorname{FIRST}$ 集合

#### 定义

​		$\operatorname{FIRST}\left(\alpha_{i}\right)=\left\{a \mid \alpha_{i} \stackrel{*}{\Rightarrow} a \beta, a \in V_{\mathrm{T}}, \alpha_{i}, \beta \in\left(V_{\mathrm{T}} \cup V_{\mathrm{N}}\right)^{*}\right\}$ ，表示可由$\alpha_i$推导出的所有开头终结符号的集合。特别地，如果 $\alpha_{i} \stackrel{*}{\Rightarrow} \varepsilon$, 则规定 $\varepsilon \in \operatorname{FIRST}\left(\alpha_{i}\right)$ 。

#### 算法：![image-20211120173802057](词法分析实验报告.assets/image-20211120173802057-16374010827465.png)

#### 计算结果

​		计算样例文法的$\operatorname{First}$集，调用`Grammar.PrintFirst()`

```c++
First:
        E: ( num 
        T: ( num 
        F: ( num
```



### 计算Follow集合

1. 定义：$\text { FOLLOW }(A)=\left\{a \mid S \stackrel{*}{\Rightarrow} \cdots A a \cdots, a \in V_{\mathrm{T}}\right\}$，表示该文法的所有句型中紧跟在$A$后的出现的终结符号或$\$$组成的集合。特别地, 若 $S \stackrel{*}{\Rightarrow} \cdots A$, 则规定 $\$ \in \mathrm{FOLLOW}(A)$，$ 为输入符号串的右结尾标志符。
2. 算法：![image-20211120174700369](词法分析实验报告.assets/image-20211120174700369-16374016211676.png)

#### 计算结果

​		计算样例文法的$\operatorname{Follow}$，调用`Grammar.PrintFollow()`

```c++
Follow:
        E: $ + - ) 
        T: $ + - * / ) 
        F: $ + - * / )
```



### 构造拓广文法

#### 定义

​		对任何文法 $G=\left(\mathbf{V}_{\mathrm{T}}, \mathbf{V}_{\mathrm{N}}, \mathbf{S}, \varphi\right)$，都有等价的文法: $\mathbf{G}^{\prime}=\left(\mathbf{V}_{\mathrm{T}}, \mathbf{V}_{\mathbf{N}} \cup\left\{\mathbf{S}^{\prime}\right\}, \mathbf{S}^{\prime}, \varphi \cup\left\{\mathbf{S}^{\prime} \rightarrow \mathbf{S}\right\}\right)$ 称 $G^{\prime}$ 为 $G$ 的拓广文法。拓广文法 $G^{\prime}$ 的接受项目是唯一的 $\left(\right.$ 即 $\left.S^{\prime} \rightarrow S^{\bullet}\right)$。

#### 计算结果

​		计算样例文法的拓广文法，调用`LRParser.GetExtG()`

```
Grammar outline: 
Symbols:
         id: 0 1, $ Terminal
         id: 1 2, ε Terminal
         id: 2 1, + Terminal
         id: 3 1, - Terminal
         id: 4 1, * Terminal
         id: 5 1, / Terminal
         id: 6 1, ( Terminal
         id: 7 1, ) Terminal
         id: 8 3, num Terminal
         id: 9 1, E Nonterminal
         id: 10 1, T Nonterminal
         id: 11 1, F Nonterminal
         id: 12 2, S' Nonterminal START
Productions:
         id: 0, E ->E+T
         id: 1, E ->E-T
         id: 2, E ->T
         id: 3, T ->T*F
         id: 4, T ->T/F
         id: 5, T ->F
         id: 6, F ->(E)
         id: 7, F ->num
         id: 8, S' ->E
```



## 递归调用分析程序的设计与实现

### 递归下降分析

#### 定义及工作过程

​		从文法的开始符号出发，进行推导，试图推出要分析的输入串的过程。对给定的输入符号串，从对应于文法开始符号的根结点出发，自顶向下地为输入串建立一棵分析树。
	试探过程，反复使用不同产生式谋求匹配输入符号串。

#### 文法要求

1. 不含左递归
2. $\forall A\rightarrow \alpha_1|\alpha_2|...|\alpha_n,\space First(\alpha_i)\cap First(\alpha_j)=\Phi(i\ne j)$

### 预测分析程序构造

1. 构造转换图

   ​		在一个非终结符号A上的转移意味着对相应A的过程的调用。在一个终结符号a上的转移，意味着下一个输入符号若为a，则应做此转移。本次实验文法的各非中介符号构造转换图如下：![image-20211120154916628](词法分析实验报告.assets/image-20211120154916628-16373945578372.png)

2. 转换图化简

   将转换图进行带入化简，简化图如下：

   ![image-20211120160111497](词法分析实验报告.assets/image-20211120160111497-16373952848043.png)

3. 分析程序的实现

   将递归分析程序存为RecurParser类，并将上图转换图封装成函数 `ProcE()`，`ProcF()`，`ProcT()`。分析程序收到词法分析结果串后，调用`Analysis()`开始递归分析。若成功，则会输出`Accept`，否则输出`Error`，并告知错误位置。

   ```c++
   class RecurParser {
     typedef vector<int> Item;
    public:
     Grammar gram;
     RecurParser(Grammar gm) : gram(gm) {}
     RecurParser() {}
     bool Analysis(Item inp);
   
    private:
     Item input;
     Symbol nowS;
     int pos;
     inline void Error() {
       printf("error at position %d : ", pos);
       nowS.print("\n");
       exit(0);
     }
     void ProcE();
     void ProcF();
     void ProcT();
     inline void fp() { nowS = gram.symbols[input[pos++]]; }
   };
   
   ```



## LL(1) 语法分析程序的设计与实现

### LL(1)文法

#### 定义

* 如果一个文法的预测分析表M不含多重定义的表项，则称该文法为LL(1)文法。
* LL(1)的含义：
  第一个L表示从左至右扫描输入符号串。第二个L表示生成输入串的一个最左推导。1表示在决定分析程序的每步动作时，向前看一个符号。

#### 判断方法

1. 一个文法是LL(1)文法，当且仅当它的每一个产生式$A\rightarrow\alpha$，满足：$\operatorname{First}(\alpha)\cap\operatorname{\beta}=\phi$，并且若$\beta$推导出$\epsilon$，则$\operatorname{Follow}(A)=\phi$。
2. 如果利用算法4.2构造出的分析表中不含多重定义的表项，则文法是LL(1)文法。

#### 预测分析表的构造算法

1. 错误处理：

   * 对于$A \in \mathbf{V}_{\mathrm{N}}, \space b \in \operatorname{FOLLOW}(A)$，若M[A,b]为空, 则加入“synch”。

   * 在使用带有同步化信息的分析表时，当前读入a，状态为A。若M[A, a]为空，则跳过a；若M[A, a]为synch，则弹出A。

2. 算法

![image-20211120193805809](词法分析实验报告.assets/image-20211120193805809-16374082868577.png)



### LL(1)非递归预测分析

#### 预测分析分析程序模型及工作流程

1. 程序组成部分：
   1. 输入缓冲区：存放被分析的输入符号串，串后随右尾标志符。
   2. 符号栈：存放一系列文法符号，存于栈底。分析开始时，先将$入栈，以标识栈底，然后再将文法的开始符号入栈。
   3. 分析表：二维数组$M[A, a]$，$A\in V_N$，$a\in V_T\cup\{\$\}$。根据给定的A和a，在分析表M中找到将被调用的产生式。
   4. 输出流：分析过程中不断产生的产生式序列。
2. 工作流程：
3. 根据栈顶符号X和当前输入符号a， 分析动作有4种可能：
   (1) $X=a=\$$，宣告分析成功，停止分析；
   (2) $X=a\ne\$$，从栈顶弹出X，输入指针前移一个位置；
   (3) $X\in V_T$，但$X\ne a$，报告发现错误，调用错误处理程序， 报告错误及进行错误恢复；
   (4) 若$X\in V_N$ ，访问分析表$M[X, a]$
   1. $M[X, a]=XY_1Y_2…Y_n$，先将X从栈顶弹出，然后把产生式的右部符号串按反序 推入栈中（即按$Y_n, …,Y_2,Y_1的顺序）；
   2. $M[X, a]=X\rightarrow\epsilon$从栈顶弹出X；
   3. $M[X, a]=ERROR$调用出错处理程序，（恢复：$M[X,a]=sync$弹出栈顶A，否则跳过a）

#### 算法

![image-20211120200215225](词法分析实验报告.assets/image-20211120200215225-16374097369261.png)

#### 类设计

```c++
class LL1Parser : public Parser {
  typedef vector<int> Item;

 private:
  // id of Nonterminal, Terminal and production
  map<pair<int, int>, int> LL1Table;
  
  void PrintStack(stack<int>& stk, const char* end);
  void PrintVec(vector<int>& vec, int start, const char* end);

 public:
  static const int ERROR = -2;
  static const int SYNC = -1;
  LL1Parser(Grammar gm) : Parser(gm){};
  bool GetLL1Table();  // return false means conflict
  void PrintTable();
  
  // conduct a LL(1) analysis
  bool LL1Analysis(Item input);
};

```



## 自底向上分析的语法分析程序的设计与实现

### LR(1)分析技术

#### 定义

1. LR(k)的含义：
   L 表示自左至右扫描输入符号串
   R 表示为输入符号串构造一个最右推导的逆过程
   k 表示为作出分析决定而向前看的输入符号的个数

2. LR分析方法的基本思想

   ​		记住已经移进和归约出的整个符号串--历史信息；
   	根据所用的产生式推测未来可能遇到的输入符号--预测信息；

   ​		根据“历史信息”和“预测信息”，以及“现实”的输入符号，确定栈顶的符号串是否构成相对于某一产生式的句柄。

#### 工作模型![LR](词法分析实验报告.assets/LR.png)



### SLR(1)分析表的构造

#### LR(0)有效项目

1. LR(0)项目
   1. 定义：右部某个位置上标有圆点的产生式称为文法G的一个LR(0)项目，例如：$A\rightarrow \cdot XYZ$，$A\rightarrow X\cdot YZ$，$A\rightarrow XY\cdot Z$，$A\rightarrow XYZ\cdot$
   2. 类别：
      1. 归约项目：圆点在产生式最右端的LR(0)项目
      2. 接受项目：对文法开始符号的归约项目
      3. 待约项目：圆点后第一个符号为非终结符号的LR(0)项目
      4. 移进项目：圆点后第一个符号为终结符号的LR(0)项目
2. LR(0)有效项目
   1. 定义：项目$A\rightarrow\beta_1\cdot\beta_2$对活前缀$\gamma=\alpha\beta$是有效的，如果存在一个规范推导：$\mathrm{S} \stackrel{*}{\Rightarrow} \alpha A \omega \Rightarrow \alpha \beta_{1} \beta_{2} \omega$。LR(0)项目$S'\rightarrow\cdot S$是活前缀$\epsilon$的有效项目。
   2. LR(0)有效项目集：文法G的某个活前缀的所有LR(0)有效项目组成的集合。
   3. LR(0)项目集规范族：文法G的所有LR(0)有效项目集组成的集合。

#### SLR(1)分析方法

1. 构造 SLR(1)分析表的基本思想是：首先为给定文法构造一个识别它的所有活前缀的确定的有限自动机,然后根据此有限自动机构造该文法的分析表。

2. SLR(1)的特点：可以通过考察follow集合解决冲突。

   1. 冲突：$I=\{X\rightarrow\alpha\cdot b\beta，A\rightarrow\alpha\cdot，B\rightarrow\beta\cdot\}$ 存在移进-归约冲突和归约-归约冲突。
   2. 解决：对于当前读入a，查看FOLLOW(A)和FOLLOW(B)。（要求：FOLLOW(A)$\cap$FOLLOW(B)=$\Phi$， $b \notin\operatorname{FOLLOW}(A)$ 并且 $b \notin\operatorname{FOLLOW}(B)$ 
      1. 当$a=b$时，把b移进栈里；
      2. 当$a\in FOLLOW(A)$时，用产生式$A\rightarrow\alpha$进行归约；
      3. 当$a\in FOLLOW(B)$时，用产生式$B\rightarrow\alpha$进行归约。

3. 构造SLR(1)分析表

   1. 闭包closure(I)：

      设I是文法G的一个LR(0)项目集合，closure(I)是从I 出发，用下面的方法构造的项目集：

      1. I中的每一个项目都属于closure(I)；
      2. 若项目$A\rightarrow\codt B\beta$属于closure(I)，且G有产生式 $B\rightarrow\eta$，若$B\rightarrow\cdot\eta$不属于closure(I)，则将$B\rightarrow\cdot\eta$ 加入 closure(I)；
      3. 重复规则 ii ，直到closure(I)不再增大为止。

   2. 转移函数go：
      若I是文法G的一个LR(0)项目集，X是一个文法符号，定义$go(I, X)=closure(J)$，其中$\mathbf{J}=\{\mathbf{A} \rightarrow \alpha \mathbf{X} \cdot \beta \mid \text { 当 } \mathbf{A} \rightarrow \alpha \cdot \mathbf{X} \beta \text { 属于 I 时 }\}$。$go(I,X)$为转移函数，项目$A\rightarrow\alpha X\cdot\beta$称为$A\rightarrow\cdot X\beta$的后续。

      

#### 算法

1. 文法的LR(0)项目集规范族的构造算法![image-20211120204219523](词法分析实验报告.assets/image-20211120204219523-16374121405752.png)

2. 求解闭包Closure算法

   ![image-20211120205402142](词法分析实验报告.assets/image-20211120205402142-16374128439483.png)

3. SLR(1)分析表的构造算法![image-20211120210309197](词法分析实验报告.assets/image-20211120210309197-16374133899884.png)

   

### LR分析控制程序

#### 算法设计![image-20211120211428004](词法分析实验报告.assets/image-20211120211428004-16374140692615.png)

#### 类设计

```c++
class LRParser : public Parser {
  typedef vector<int> Item;
  typedef pair<int, Item> LR0Item;  // LR(0) item: id of nonterminal, Item
  typedef vector<LR0Item> LR0Set;   // LR(0) item set
  typedef vector<LR0Set> LR0Fmly;   // LR(0) item set specification family

  const int DOT_ID = -1;

 private:
  bool isExt;

 public:
  enum ActionType { SHIFT, REDUCE, ACCEPT, ERROR } actionType;
  Grammar extGram;

 private:
  LR0Fmly lR0Fmly;

  // <state id, nonterminal id> -> next state id
  map<pair<int, int>, int> gotoTable;

  // <state id, terminal id> -> <action type, action code>
  map<pair<int, int>, pair<ActionType, int>> actionTable;

  // get extended grammar
  void GetExtG();

  // closure{nowItem} => nowSet
  void GetClosure(LR0Item item, LR0Set& set);
  
  // go(set, x) => newSet
  void GetGo(LR0Set nowSet, int x, LR0Set& newSet);
  
  void PrintLR0Item(const LR0Item& lR0Item, const char* end);
  void PrintLR0Set(const LR0Set& lR0Set, const char* end);
  
  // print LR(0) set family and DFA
  void PrintLR0Fmly();
  
  void PrintStk(vector<pair<int, int>>& stk, const char* c);

 public:
  LRParser(Grammar gm) : Parser(gm) {
    isExt = false;
    GetExtG();
  };
  ~LRParser(){};
  
  // Get SLR(1) analysis table
  void GetSLRTable();
  
  void PrintLRTable();
  
  // conduct a SLR(1) analysis
  bool SLRAnalysis(Item input);
};

```



## YACC自动生成语法分析程序

### YACC简介

- yacc(Yet Another Compiler Compiler)，是Unix/Linux上一个用来生成编译器的编译器（编译器代码生成器）.
   使用巴克斯范式(BNF)定义语法，能处理上下文无关文法(context-free)。出现在每个产生式左边(left-hand side：lhs)的符号是非终端符号，出现在产生式右边(right-hand side：rhs)的符号有非终端符号和终端符号，但终端符号只出现在右端。
   yacc是开发编译器的一个有用的工具,采用LR（1）（实际上是LALR(1)）语法分析方法。
   LR(k)分析方法是1965年Knuth提出的，括号中的k（k >=0）表示向右查看输入串符号的个数。LR分析法正视给出一种能根据当前分析栈中的符号串和向右顺序查看输入串的k个符号就可唯一确定分析器的动作是移进还是规约和用哪个产生式规约。
   这种方法具有分析速度快，能准确，即使地指出出错的位置，它的主要缺点是对于一个使用语言文法的分析器的构造工作量相当大，k愈大构造愈复杂，实现比较困难。

一个LR分析器有3个部分组成：

- **总控程序，也可以称为驱动程序。**
   对所有的LR分析器总控程序都是相同的。
- **分析表或分析函数。**
   不同的文法分析表将不同，同一个文法采用的LR分析器不同时，分析表也不同，分析表又可分为动作(ACTION)表和状态转换(GOTO)表两个部分，它们都可用二维数组表示。
- **分析栈，包括文法符号栈和相应的状态栈。**
   它们均是先进后出栈。 分析器的动作由栈顶状态和当前输入符号所决定(LR(0)分析器不需要向前查看输入符号)。
   LR分析器工作过程如下 :
   其中SP为栈指针，S[i]为状态栈，X[i]为文法符号栈。状态转换表内容按关系GOTO[Si，X] = Sj确定，该关系式是指当栈顶状态为Si遇到当前文法符号为X时应转向状态Sj。X为终结符或非终结符。 ACTION[Si，a]规定了栈顶状态为Si是遇到输入符号a应执行的动作。

本文讨论yacc语法的格式并描述可用的各种特征和选项

### 和词法分析Lex间的通信







# 测试报告

## 测试程序说明

1. lex
2. Rectest
3. LL1test
4. LRtest
5. LL1synthesis
6. LRsynthesis



## 测试结果与说明

